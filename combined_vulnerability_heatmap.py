# -*- coding: utf-8 -*-
"""
Created on Thu Oct 22 15:58:28 2020

@author: Andrea
"""


import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
import os
import conda
conda_file_dir = conda.__file__
conda_dir = conda_file_dir.split('lib')[0]
proj_lib = os.path.join(os.path.join(conda_dir, 'share'), 'proj')
os.environ["PROJ_LIB"] = proj_lib

from mpl_toolkits.basemap import Basemap
#from mpi4py import MPI
import pandapower as pp
import pandapower.networks
import numpy as np
import sys
import time
import random
import itertools
import networkx as nx
import multiprocessing  
import pandapower.plotting as pplt
import math
#import geopy.distance
#from geopy.point import Point
from cascade_power import OPA_model
import collections
import copy
###################################### INITIALIZE RAILWAY AND POWER NETWORKS #################
list_station = [
                    'Glasgow', 'Edinburgh', 'Newcastle', 'Tees Valley', 
                    'Leeds', 'Sheffield', 'Nottingham', 'Cambridge',
                    'Stansted', 'London', 'Heathrow', 'Bristol',
                    'Cardiff', 'Birmingham', 'Manchester', 'Liverpool'
                    ]

list_railway = [
               (0, 1), (0, 14), (0, 13), (1, 2), (1, 13), 
               (2, 3), (3, 4), (4, 5), (4, 14), 
               (5, 6), (5, 14), (6, 7), (7, 8), 
               (7, 9), (8, 9), (9, 10), (9, 13), 
               (10, 11), (11, 12), (13, 14), (14,15)
               ]   

net = pp.networks.GBreducednetwork()
G=pp.topology.create_nxgraph(net)
    
pp.replace_sgen_by_gen(net)
list_ext_grid  = list(net.ext_grid.index)
initial_slack = pp.replace_ext_grid_by_gen(net, list_ext_grid, slack=True)    
net.line.loc[:,'max_loading_percent'] = 100
net.trafo.loc[:,'max_loading_percent'] = 100

net.load.loc[:,'max_p_mw'] = net.load.p_mw
net.load.loc[:,'min_p_mw'] = 0

net.gen.loc[:,'max_p_mw'] = net.gen.max_p_mw/1.438
net.gen.loc[:,'p_mw'] = net.gen.max_p_mw

list_load_bus = list(net.load.bus)
list_load_bus.sort()

net.load.loc[:,'controllable'] = True


net.poly_cost.loc[:,'cp0_eur'] = 0
net.poly_cost.loc[:,'cp1_eur_per_mw'] = 1
net.poly_cost.loc[:,'cp2_eur_per_mw2'] = 0


list_load =list(net.load.index)
for load in list_load:
    globals()['costload%s' %load] = pp.create_poly_cost(net, load, 'load',cp0_eur=0,
                                                        cp1_eur_per_mw = -100,cp2_eur_per_mw2=0)

initial_state_load = dict(net.load.loc[:,'p_mw'])
order_dict_load = collections.OrderedDict(sorted(initial_state_load.items()))
initial_load_power = list(order_dict_load.values())


# initial_interdep_power = power to subtract to each load when one of the corresponding station is failed
list_interdependencies = [4, 3, 9, 9, 14, 13, 16, 20, 20, 24, 24, 22, 28, 17, 12, 11]
set_interdependencies = list(set(list_interdependencies))
initial_interdep_power = np.zeros(len(initial_load_power))
for i,l in enumerate(initial_load_power):
    counter = list_interdependencies.count(i)
    if counter > 0:
        initial_interdep_power[i] = l/counter
    else:
        initial_interdep_power[i] = 0



n_bus = len(list(net.bus.index))
n_line = len(list(net.line.index))
n_trafo = len(list(net.trafo.index))
n_comp_power = n_bus + n_line + n_trafo
list_components_power = list(range(n_comp_power))

n_station = 16
n_railway = 21
n_comp_rail = n_station + n_railway
list_components_rail = list(range(n_comp_rail))

# Define if the component n is a bus, a normal line or a line with a trafo
def power_failed_element(n, f_bus, f_line, f_trafo):
    lim_1 = n_bus
    lim_2 = lim_1 + n_line
    if n < lim_1:
        f_bus += [n]
    elif n >= lim_1 and n < lim_2:
        f_line += [n - lim_1]
    elif n >= lim_2:
        f_trafo += [n - lim_2]
    
    return(f_bus, f_line, f_trafo)

# Define if the component n is a station or a railway
def rail_failed_element(n, f_station, f_rail):
    lim_1 = n_station
    if n < lim_1:
        f_station += [n]
    elif n >= lim_1:
        f_rail += [n - lim_1]
    return(f_station, f_rail)

# Adjacency matrix railway
adj_matrix_rail = np.zeros((len(list_station), len(list_station)))
for i in list_railway:
    adj_matrix_rail[i[0]][i[1]] = 1
    adj_matrix_rail[i[1]][i[0]] = 1
    

# This function computes the accessibility of a railway network given its adjacency matrix
def accessibility(matrix):
    G = nx.convert_matrix.from_numpy_array(matrix)
    if nx.is_connected(G):
        C = 1
    else:
        conn = 0
        nominal_conn = math.comb(len(matrix[0]), 2)
        islands = list(nx.connected_components(G))
        for i in islands:
            #print(islands)
            couples = math.comb(len(i), 2)
            conn += couples
        C = conn/nominal_conn
    return(C)

power_threshold = 0.5
n_exp = 500

matrix_vulnerability_rail = np.zeros((11,11))
matrix_vulnerability_rail_std = np.zeros((11,11))
matrix_vulnerability_power = np.zeros((11,11))
matrix_vulnerability_power_std = np.zeros((11,11))

idx_frac_rail = 0

frazioni = list(np.arange(0.0,1.1,0.1))

for idx_frac_rail, frac_rail in enumerate(frazioni[:]):

    for idx_frac_power, frac_power in enumerate(frazioni[:]):
        
        vuln_frac_power = np.zeros(n_exp)
        vuln_frac_rail = np.zeros(n_exp)
        exp = 0
        while exp < n_exp:
            print(frac_rail, frac_power, exp)
            
            # Define elements to remove in both the networks
            n_failures_power = int(n_comp_power*frac_power)
            list_failures_power = random.sample(list_components_power, k=n_failures_power)
            n_failures_rail = int(n_comp_rail*frac_rail)
            list_failures_rail = random.sample(list_components_rail, k=n_failures_rail)
            f_bus = []; f_line = []; f_trafo = []; f_station = []; f_rail = []
            for f in list_failures_power:
                f_bus, f_line, f_trafo = power_failed_element(f, f_bus, f_line, f_trafo)
            for f in list_failures_rail:
                f_station, f_rail = rail_failed_element(f, f_station, f_rail)
            
            # Initialize networks
            new_matrix = np.copy(adj_matrix_rail)
            net_GB = copy.deepcopy(net)
            
            # Remove elements from railway network
            for f in f_station:
                new_matrix[f, :] = 0
                new_matrix[:, f] = 0
            for f in f_rail:
                new_matrix[list_railway[f][0], list_railway[f][1]] = 0
                new_matrix[list_railway[f][1], list_railway[f][0]] = 0 
            G = nx.convert_matrix.from_numpy_array(new_matrix)
            
            # Cascading failures in railway network
            islands = list(nx.connected_components(G))
            for isl in islands:
                isl = list(isl)
                if len(isl) == 1:
                    if isl[0] not in f_station:
                        f_station += [isl[0]]
            f_station = list(set(f_station))
            # Adjust loads powers
            for f in f_station:
                load_sh = list_interdependencies[f]
                net_GB.load.loc[load_sh, 'p_mw'] -= initial_interdep_power[load_sh]
                net_GB.load.loc[load_sh, 'max_p_mw'] -= initial_interdep_power[load_sh]
                if net_GB.load.loc[load_sh, 'p_mw'] < 0:
                    net_GB.load.loc[load_sh, 'p_mw'] = 0
                if net_GB.load.loc[load_sh, 'max_p_mw'] < 0:
                    net_GB.load.loc[load_sh, 'max_p_mw'] = 0                
            
            # Run cascading failures in power networks 
            initial_state_load = dict(net_GB.load.loc[:,'p_mw'])
            order_dict_load = collections.OrderedDict(sorted(initial_state_load.items()))
            new_initial_load_power = list(order_dict_load.values())
            for i,j in enumerate(new_initial_load_power):
                if j == 0:
                    new_initial_load_power[i] = 0
                    
            g,l = OPA_model(net_GB, f_bus, [], [], f_line, f_trafo)
            
            l = np.around(l, 2)
            
            load_shedding = np.zeros(len(new_initial_load_power))
            for i,j in enumerate(l):
                if new_initial_load_power[i] > 0:
                    load_shedding[i] = j/new_initial_load_power[i]
                else:
                    load_shedding[i] = 1
            
            load_shedding = np.around(load_shedding, 2)
            '''
            print(sum(load_shedding)/len(load_shedding))
            print(new_initial_load_power)
            print(l)
            '''
            # Cascading failures between networks
            for i,j in enumerate(list_interdependencies):
                if load_shedding[j] < power_threshold or load_shedding[j] == 0:
                    if i not in f_station:
                        f_station += [i]
            # Compute vulnerabilities
            for f in f_station:
                new_matrix[f, :] = 0
                new_matrix[:, f] = 0
            for f in f_rail:
                new_matrix[list_railway[f][0], list_railway[f][1]] = 0
                new_matrix[list_railway[f][1], list_railway[f][0]] = 0 
            delta_conn = 1 - accessibility(new_matrix)
            vuln_frac_rail[exp] = delta_conn
            if sum(new_initial_load_power) > 0:
                vuln_power_shed = sum(l)/sum(new_initial_load_power)
            else:
                vuln_power_shed = 1 
            vuln_frac_power[exp] = 1-vuln_power_shed 
            exp += 1
        v_rail = sum(vuln_frac_rail)/n_exp
        v_power = sum(vuln_frac_power)/n_exp
        matrix_vulnerability_rail[idx_frac_rail][idx_frac_power] = v_rail
        matrix_vulnerability_power[idx_frac_rail][idx_frac_power] = v_power
        matrix_vulnerability_rail_std[idx_frac_rail][idx_frac_power] = np.std(vuln_frac_rail)
        matrix_vulnerability_power_std[idx_frac_rail][idx_frac_power] = np.std(vuln_frac_power)
'''
matrix_vulnerability_rail[-1,:] = 1
matrix_vulnerability_rail[:,-1] = 1
matrix_vulnerability_power[:,-1] = 1
'''
        
np.save(os.path.join('vuln_pr', 'matrix_vulnerability_rail_'+str(int(power_threshold*100))),
        matrix_vulnerability_rail)

np.save(os.path.join('vuln_pr', 'matrix_vulnerability_power_'+str(int(power_threshold*100))),
        matrix_vulnerability_power)  


np.save(os.path.join('vuln_pr', 'std_matrix_vulnerability_rail_'+str(int(power_threshold*100))),
        matrix_vulnerability_rail_std)

np.save(os.path.join('vuln_pr', 'std_matrix_vulnerability_power_'+str(int(power_threshold*100))),
        matrix_vulnerability_power_std)











    