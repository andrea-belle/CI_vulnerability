
# -*- coding: utf-8 -*-
"""
Created on Wed Dec  2 13:55:28 2020

@author: Andrea Bell√®
"""

import numpy as np
import collections
import os
import pandapower as pp
import pandapower.networks
import networkx as nx
import time
import math
import sys
from cascading_failures_power import OPA_model
import matplotlib.pyplot as plt
import random
import copy
#import seaborn as sb
#import multiprocessing  
#import pandapower.plotting as pplt
#from mpl_toolkits.axes_grid1 import make_axes_locatable
#from sklearn.linear_model import LinearRegression
#from sklearn.metrics import mean_squared_error, r2_score
#from matplotlib.patches import Patch
#from matplotlib.lines import Line2D
#from glob import glob
#from pylab import *
#from matplotlib import cm
#from mpl_toolkits.mplot3d import Axes3D
#from mpl_toolkits.basemap import Basemap
#from mpi4py import MPI
#import itertools
'''
import conda
conda_file_dir = conda.__file__
conda_dir = conda_file_dir.split('lib')[0]
proj_lib = os.path.join(os.path.join(conda_dir, 'share'), 'proj')
os.environ["PROJ_LIB"] = proj_lib
'''

##############################################################################
time_start = time.process_time()
##############################################################################

# INITIALIZATION OF THE POWER NETWORK

# Call the Great Britain reduced power network from Pandapower
net = pandapower.networks.GBreducednetwork()

# Replace static generators with standard generators
pp.replace_sgen_by_gen(net)
    
# Set the maximum loading of each line to 100%   
net.line.loc[:,'max_loading_percent'] = 100
net.trafo.loc[:,'max_loading_percent'] = 100

# Set the min/max power values of each load
net.load.loc[:,'max_p_mw'] = net.load.p_mw
net.load.loc[:,'min_p_mw'] = 0

# Set the min/max power values of each generator
net.gen.loc[:,'max_p_mw'] = net.gen.max_p_mw/1.438
net.ext_grid.loc[:,'max_p_mw'] = net.ext_grid.max_p_mw/1.438
net.gen.loc[:,'p_mw'] = net.gen.max_p_mw

# Set generators and loads as controllable (for DC OPF)
net.gen.loc[:,'controllable'] = True
net.load.loc[:,'controllable'] = True

# Set cost function for each generator
net.poly_cost.loc[:,'cp0_eur'] = 0
net.poly_cost.loc[:,'cp1_eur_per_mw'] = 1
net.poly_cost.loc[:,'cp2_eur_per_mw2'] = 0

# Set cost function for each load
list_load =list(net.load.index)
for load in list_load:
    pp.create_poly_cost(net, load, 'load',cp0_eur=0,
                        cp1_eur_per_mw = -100,cp2_eur_per_mw2=0)

# Compute the initial power of each load to determine the load shedding
initial_state_load = dict(net.load.loc[:,'p_mw'])
order_dict_load = collections.OrderedDict(sorted(initial_state_load.items()))
initial_load_power = list(order_dict_load.values())


# List of railway stations. Not really needed, it is just for showing the station index
list_station = [
                'Glasgow', 'Edinburgh', 'Newcastle', 'Tees Valley', 
                'Leeds', 'Sheffield', 'Nottingham', 'Cambridge',
                'Stansted', 'London', 'Heathrow', 'Bristol',
                'Cardiff', 'Birmingham', 'Manchester', 'Liverpool'
               ]
# List of buses (loads) which provides electricity to each station (computed separately)
list_interdependencies = [4, 3, 9, 9, 14, 13, 16, 20, 20, 24, 24, 22, 28, 17, 12, 11]

n_bus = len(list(net.bus.index))               # number of buses
n_line = len(list(net.line.index))             # number of lines
n_trafo = len(list(net.trafo.index))           # number of transformers
n_components = n_bus + n_line + n_trafo        # number of elements
list_components = list(range(n_components))    # list element index

# List of railways (station 1, station 2)
list_railway = [
               (0, 1), (0, 14), (0, 13), (1, 2), (1, 13), 
               (2, 3), (3, 4), (4, 5), (4, 14), 
               (5, 6), (5, 14), (6, 7), (7, 8), 
               (7, 9), (8, 9), (9, 10), (9, 13), 
               (10, 11), (11, 12), (13, 14), (14,15)
               ]    

# Build adjacency matrix of the railway network
adj_matrix_rail = np.zeros((len(list_station), len(list_station)))
for i in list_railway:
    adj_matrix_rail[i[0]][i[1]] = 1
    adj_matrix_rail[i[1]][i[0]] = 1
    

# This function computes the accessibility of a railway network given its adjacency matrix
def accessibility(matrix):
    G = nx.convert_matrix.from_numpy_array(matrix)
    if nx.is_connected(G):
        C = 1
    else:
        conn = 0
        nominal_conn = math.comb(len(matrix[0]), 2)
        islands = list(nx.connected_components(G))
        for i in islands:
            #print(islands)
            couples = math.comb(len(i), 2)
            conn += couples
        C = conn/nominal_conn
    return(C)


# List of fraction of removals to test
list_frac = list(np.arange(0.0,1.1,0.1))


# Empty arrays for containing the vulnerability values and the standard deviations
list_vulnerability_rail = np.zeros(len(list_frac))
list_standard_deviation = np.zeros(len(list_frac))

percentage_direct_removal = np.zeros(len(list_frac))
list_standard_deviation_direct = np.zeros(len(list_frac))

percentage_casc_removal = np.zeros(len(list_frac))
list_standard_deviation_casc = np.zeros(len(list_frac))

percentage_disc_removal = np.zeros(len(list_frac))
list_standard_deviation_disc = np.zeros(len(list_frac))


# Threshold T_{p,i} for the failure of stations due to lack of electricity supply
power_threshold = 1.0

# Number of experiments per fraction of removals
n_exp = 10

for idx_f, frac in enumerate(list_frac):
    #print(frac)
    vuln_frac = np.zeros(n_exp)            # Empty array for rail vulnerability
    direct_perc_frac = np.zeros(n_exp)     # Empty array for fraction of direct failures
    casc_perc_frac = np.zeros(n_exp)       # Empty array for fraction of cascade failures
    disc_perc_frac = np.zeros(n_exp)       # Empty array for fraction of disconnection failures
    exp = 0
    while exp < n_exp:
        print(frac, exp)
        # Counters for failure modes fraction
        perc_direct = 0
        perc_casc = 0
        perc_disc = 0
        # Number of elements to remove in the power network
        n_failures = int(n_components*frac)
        # Random sampling of elements to remove in the power network
        list_failures = random.sample(list_components, k=n_failures)
        
        # Define if the elements are buses, lines or transformers
        f_bus = []
        f_line = []
        f_trafo = []
        for f in list_failures:
            if f < n_bus:
                f_bus += [f]
            elif f >= n_bus and f < n_bus + n_line :
                f_line += [f - n_bus]
            else:
                f_trafo += [f - n_bus - n_line]
                
        # Run the cascding failures in the power network
        net_GB = copy.deepcopy(net)
        g,l = OPA_model(net_GB, f_bus, [], [], f_line, f_trafo)
        
        # Compute the load shedding
        load_shedding = l/initial_load_power
        load_shedding = np.around(load_shedding, 2)
        
        # Compare the load shedding with the interdependency list
        # and check which stations are failed due to lack of electricity
        list_failures_rail = []
        for i,j in enumerate(list_interdependencies):
            if load_shedding[j] < power_threshold or load_shedding[j] == 0:
                list_failures_rail += [i]
                if j in f_bus:
                    perc_direct += 1
                else:
                    perc_casc += 1
        
        # Remove the failed stations from the railway adjacency matrix
        new_matrix = np.copy(adj_matrix_rail)
        for f in list_failures_rail:
            new_matrix[f, :] = 0
            new_matrix[:, f] = 0

        # Check if some stations fail due to disconnection    
        G = nx.convert_matrix.from_numpy_array(new_matrix)
        islands = list(nx.connected_components(G))
        for isl in islands:
            isl = list(isl)
            if len(isl) == 1:
                if isl[0] not in list_failures_rail:
                    new_matrix[f, :] = 0
                    new_matrix[:, f] = 0
                    list_failures_rail += [isl[0]]
                    perc_disc += 1
        
        # Compute the fraction of failure modes (direct, cascade, disconnection)           
        try:
            perc_direct /= len(list_failures_rail)
        except ZeroDivisionError:
            perc_direct = 0
        try:
            perc_casc /= len(list_failures_rail)
        except ZeroDivisionError:
            perc_casc = 0
        try:
            perc_disc /= len(list_failures_rail)
        except ZeroDivisionError:
            perc_disc = 0
        
        # Compute loss of connectivity and add the value to the corresponding list
        delta_accessibility = 1 - accessibility(new_matrix)
        vuln_frac[exp] = delta_accessibility

        # Add the failure modes fraction to the corresponding lists
        direct_perc_frac[exp] = perc_direct
        casc_perc_frac[exp] = perc_casc
        disc_perc_frac[exp] = perc_disc
        
        exp += 1
     
    # Store results and standard deviations
    ave_vuln_frac = sum(vuln_frac)/n_exp
    list_vulnerability_rail[idx_f] = ave_vuln_frac
    list_standard_deviation[idx_f] = np.std(vuln_frac)
    
    ave_perc_direct = sum(direct_perc_frac)/n_exp
    percentage_direct_removal[idx_f] = ave_perc_direct
    list_standard_deviation_direct[idx_f] = np.std(direct_perc_frac)

    ave_perc_casc = sum(casc_perc_frac)/n_exp
    percentage_casc_removal[idx_f] = ave_perc_casc
    list_standard_deviation_casc[idx_f] = np.std(casc_perc_frac)

    ave_perc_disc = sum(disc_perc_frac)/n_exp
    percentage_disc_removal[idx_f] = ave_perc_disc
    list_standard_deviation_disc[idx_f] = np.std(disc_perc_frac)
    

# Compute 95% confidence intervals
Z = 1.960
list_confidence_intervals_vuln = Z * (list_standard_deviation/np.sqrt(n_exp))  
list_confidence_intervals_direct = Z * (list_standard_deviation_direct/np.sqrt(n_exp))  
list_confidence_intervals_casc = Z * (list_standard_deviation_casc/np.sqrt(n_exp))  
list_confidence_intervals_disc = Z * (list_standard_deviation_disc/np.sqrt(n_exp))  


print('Elapsed time: ', time.process_time() - time_start)


# If you need to save the results...        
                
'''
np.save(os.path.join('data_interdep/power_to_rail', 'vulnerability_rail_pt_'+str(int(power_threshold*100))),
        list_vulnerability_rail) 
np.save(os.path.join('data_interdep/power_to_rail', 'list_confidence_intervals_pt_'+str(int(power_threshold*100))),
        list_confidence_intervals_vuln) 

np.save(os.path.join('data_interdep/power_to_rail', 'perc_direct_pt_'+str(int(power_threshold*100))),
        percentage_direct_removal) 
np.save(os.path.join('data_interdep/power_to_rail', 'list_confidence_intervals_direct_pt_'+str(int(power_threshold*100))),
        list_confidence_intervals_direct) 

np.save(os.path.join('data_interdep/power_to_rail', 'perc_casc_pt_'+str(int(power_threshold*100))),
        percentage_casc_removal) 
np.save(os.path.join('data_interdep/power_to_rail', 'list_confidence_intervals_casc_pt_'+str(int(power_threshold*100))),
        list_confidence_intervals_casc)

np.save(os.path.join('data_interdep/power_to_rail', 'perc_disc_pt_'+str(int(power_threshold*100))),
        percentage_disc_removal) 
np.save(os.path.join('data_interdep/power_to_rail', 'list_confidence_intervals_perc_disc_pt_'+str(int(power_threshold*100))),
        list_confidence_intervals_disc)
'''


##### PLOTTING ######


fig, ax = plt.subplots(1, 1, figsize=(15, 10))

#ax.plot(list_frac, list_vulnerability_rail, 'o-') 
ax.errorbar(list_frac, list_vulnerability_rail, yerr=list_confidence_intervals_vuln,
            fmt='-o', color='black')

major_ticks_x = np.arange(0, 1.1, 0.1)
minor_ticks_x = np.arange(0, 1.01, 0.01)
major_ticks_y = np.arange(0, 1.1, 0.1)
minor_ticks_y = np.arange(0, 1.01, 0.01)

ax.set_xticks(major_ticks_x)
ax.set_xticks(minor_ticks_x, minor=True)
ax.set_yticks(major_ticks_y)
ax.set_yticks(minor_ticks_y, minor=True)

ax.tick_params(axis='y', labelcolor='black', labelsize=20)
ax.tick_params(axis='x', labelcolor='black', labelsize=20)

ax.grid(which='both')
ax.grid(which='minor', alpha=0.2)
ax.grid(which='major', alpha=0.4)

plt.xlabel('Fraction of removed components (power network)', size = 20)  
plt.ylabel('Average loss of accessibility (railway network)', size = 20) 


plt.ylim([0,1.01])
plt.xlim([0,1.01])




#plt.savefig('immagini/vuln_conn_power_to_rail.png', bbox_inches = "tight")
plt.show()





  











    
