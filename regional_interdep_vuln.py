# -*- coding: utf-8 -*-
"""
Created on Thu Oct 22 15:58:28 2020

@author: Andrea
"""


import numpy as np
import collections
import os
import pandapower as pp
import pandapower.networks
import networkx as nx
import time
import math
import sys
from cascade_power import OPA_model
import matplotlib.pyplot as plt
import random
import copy
import matplotlib as mpl
import cycler
#import seaborn as sb
#import multiprocessing  
#import pandapower.plotting as pplt
#from mpl_toolkits.axes_grid1 import make_axes_locatable
#from sklearn.linear_model import LinearRegression
#from sklearn.metrics import mean_squared_error, r2_score
#from matplotlib.patches import Patch
#from matplotlib.lines import Line2D
#from glob import glob
#from pylab import *
#from matplotlib import cm
#from mpl_toolkits.mplot3d import Axes3D
#from mpl_toolkits.basemap import Basemap
#from mpi4py import MPI
#import itertools
'''
import conda
conda_file_dir = conda.__file__
conda_dir = conda_file_dir.split('lib')[0]
proj_lib = os.path.join(os.path.join(conda_dir, 'share'), 'proj')
os.environ["PROJ_LIB"] = proj_lib
'''


##############################################################################
time_start = time.process_time()
##############################################################################

# INITIALIZATION OF THE POWER NETWORK

# Call the Great Britain reduced power network from Pandapower
net = pandapower.networks.GBreducednetwork()

# Replace static generators with standard generators
pp.replace_sgen_by_gen(net)
list_ext_grid  = list(net.ext_grid.index)
initial_slack = pp.replace_ext_grid_by_gen(net, list_ext_grid, slack=True) 
    
# Set the maximum loading of each line to 100%   
net.line.loc[:,'max_loading_percent'] = 100
net.trafo.loc[:,'max_loading_percent'] = 100

# Set the min/max power values of each load
net.load.loc[:,'max_p_mw'] = net.load.p_mw
net.load.loc[:,'min_p_mw'] = 0

# Set the min/max power values of each generator
net.gen.loc[:,'max_p_mw'] = net.gen.max_p_mw/1.438
#net.ext_grid.loc[:,'max_p_mw'] = net.ext_grid.max_p_mw/1.438
net.gen.loc[:,'p_mw'] = net.gen.max_p_mw

# Set generators and loads as controllable (for DC OPF)
net.gen.loc[:,'controllable'] = True
net.load.loc[:,'controllable'] = True

# Set cost function for each generator
net.poly_cost.loc[:,'cp0_eur'] = 0
net.poly_cost.loc[:,'cp1_eur_per_mw'] = 1
net.poly_cost.loc[:,'cp2_eur_per_mw2'] = 0

# Set cost function for each load
list_load =list(net.load.index)
for load in list_load:
    pp.create_poly_cost(net, load, 'load',cp0_eur=0,
                        cp1_eur_per_mw = -100,cp2_eur_per_mw2=0)

# Compute the initial power of each load to determine the load shedding
initial_state_load = dict(net.load.loc[:,'p_mw'])
order_dict_load = collections.OrderedDict(sorted(initial_state_load.items()))
initial_load_power = list(order_dict_load.values())


# List of railway stations. Not really needed, it is just for showing the station index
list_station = [
                'Glasgow', 'Edinburgh', 'Newcastle', 'Tees Valley', 
                'Leeds', 'Sheffield', 'Nottingham', 'Cambridge',
                'Stansted', 'London', 'Heathrow', 'Bristol',
                'Cardiff', 'Birmingham', 'Manchester', 'Liverpool'
               ]
# List of buses (loads) which provides electricity to each station (computed separately)
list_interdependencies = [4, 3, 9, 9, 14, 13, 16, 20, 20, 24, 24, 22, 28, 17, 12, 11]

n_bus = len(list(net.bus.index))               # number of buses
n_line = len(list(net.line.index))             # number of lines
n_trafo = len(list(net.trafo.index))           # number of transformers
n_components = n_bus + n_line + n_trafo        # number of elements
list_components = list(range(n_components))    # list element index

# List of railways (station 1, station 2)
list_railway = [
               (0, 1), (0, 14), (0, 13), (1, 2), (1, 13), 
               (2, 3), (3, 4), (4, 5), (4, 14), 
               (5, 6), (5, 14), (6, 7), (7, 8), 
               (7, 9), (8, 9), (9, 10), (9, 13), 
               (10, 11), (11, 12), (13, 14), (14,15)
               ] 
   
# List of power network nodes in each region
regions_power = [
                [[0,1]],
                [[2,3,4,5,6,7,8,9]],
                [[10,11,12,14,17]],
                [[13,15,16,18,19,20,21]], 
                [[22,28]],
                [[23,24,25,26,27]]
                ]     

# List of railway network nodes in each region
regions_rail = [
               [[]],
               [[0,1,2,3]],
               [[4,5,13,14,15]],
               [[6,7,8]], 
               [[11,12]],
               [[9,10]]
               ] 

# In the list of lists "regions_power", for each region,
# add list of lines and list of trafos
lines = list(net.line.index); lines.sort()
trafos = list(net.trafo.index); trafos.sort()
for idx_reg, region in enumerate(regions_power):
    list_line_region = []
    for line in lines:
        if net.line.loc[line,'to_bus'] in region[0] or net.line.loc[line,'from_bus'] in region[0]:
            list_line_region += [line]
    regions_power[idx_reg].append(list_line_region)
    list_trafo_region = []
    for trafo in trafos:
        if net.trafo.loc[trafo,'hv_bus'] in region[0] or net.trafo.loc[trafo,'lv_bus'] in region[0]:
            list_trafo_region += [trafo]
    regions_power[idx_reg].append(list_trafo_region)

# In the list of lists "regions_rail", for each region,
# add list of railways
for idx_reg, region in enumerate(regions_rail):
    list_rail_region = []
    for idx_rail, rail in enumerate(list_railway):
        if rail[0] in region[0] or rail[1] in region[0]:
            list_rail_region += [idx_rail]
    regions_rail[idx_reg].append(list_rail_region)


# This function is for recognizing if the index of the failed element 
# defines a bus, a line or a trafo
def power_failed_element(n, region, f_bus, f_line, f_trafo):
    n_bus = len(region[0]); n_line = len(region[1])
    lim_1 = n_bus
    lim_2 = lim_1 + n_line
    if n < lim_1:
        f_bus += [region[0][n]]
    elif n >= lim_1 and n < lim_2:
        f_line += [region[1][n - lim_1]]
    elif n >= lim_2:
        f_trafo += [region[2][n - lim_2]]    
    return(f_bus, f_line, f_trafo)

# Construct the adjacency matrix of the railway network
adj_matrix_rail = np.zeros((len(list_station), len(list_station)))
for i in list_railway:
    adj_matrix_rail[i[0]][i[1]] = 1
    adj_matrix_rail[i[1]][i[0]] = 1
    

# Threshold T_{p,i} for the failure of stations due to lack of electricity supply
power_threshold = 1.0

# Number of experiments per fraction of removals
n_exp = 100

# List of fraction of removals to test
list_frac = list(np.arange(0.0,1.1,0.1))

# Lists of total failed stations per region and standard deviation
# Dimensions: [region of removal, impact (6 regions + total), fraction of removal]
region_vulnerability_matrix = np.zeros((6,7,len(list_frac)))
standard_deviation_matrix = np.zeros((6,7,len(list_frac)))

for idx_event_r, region in enumerate(regions_power[3:4]):
    
    # For each region, build list of components indeces (bus+line+trafo)
    n_comp_power = len(region[0]) + len(region[1]) + len(region[2])
    list_components_power = list(range(n_comp_power))
    
    for idx_frac, frac in enumerate(list_frac):
        
        # List of total failed stations
        lost_stations = np.zeros((7,n_exp))
        
        # Experiment counter
        exp = 0
        
        while exp < n_exp:
            print(idx_event_r, frac, exp)
            
            # Define failed buses, lines and trafos
            n_failures_power = int(n_comp_power*frac)
            list_failures_power = random.sample(list_components_power, k=n_failures_power)
            f_bus = []; f_line = []; f_trafo = [];
            for f in list_failures_power:
                f_bus, f_line, f_trafo = power_failed_element(f, region, f_bus, f_line, f_trafo)
            
            # Run cascading failures and load shedding in power network
            net_GB = copy.deepcopy(net)
            g,l = OPA_model(net_GB, f_bus, [], [], f_line, f_trafo)
            load_shedding = l/initial_load_power
            load_shedding = np.around(load_shedding, 2)
            
            #check which stations are failed
            f_station = []            
            new_matrix = np.copy(adj_matrix_rail)            
            for i,j in enumerate(list_interdependencies):
                if load_shedding[j] < power_threshold or load_shedding[j]==0: 
                    if i not in f_station:
                        f_station += [i]
            for f in f_station:
                new_matrix[f, :] = 0
                new_matrix[:, f] = 0
            
            # Check if any station is disconnected
            G = nx.convert_matrix.from_numpy_array(new_matrix)
            islands = list(nx.connected_components(G))
            for isl in islands:
                isl = list(isl)
                if len(isl) == 1:
                    if isl[0] not in f_station:
                        f_station += [isl[0]]
                        
            # For each failed station, check to which region it belongs
            for f in f_station:
                for idx_reg_r, r in enumerate(regions_rail):
                    if f in r[0]:
                        lost_stations[idx_reg_r, exp] += 1
            #print(f_station)
            lost_stations[6,exp] = len(f_station)
            exp += 1 
            
        for idx_r in range(len(regions_power)+1):
            ave = sum(lost_stations[idx_r, :])/n_exp
            region_vulnerability_matrix[idx_event_r, idx_r, idx_frac] = ave
            standard_deviation_matrix[idx_event_r, idx_r, idx_frac] = np.std(lost_stations[idx_r, :])



np.save(os.path.join('data_interdep', 'final_region_vulnerability_matrix_t'+str(int(power_threshold*100))+'.npy'),
        region_vulnerability_matrix) 




##### PLOTTING ######

list_frac=list(np.arange(0.0,110,10))

major_ticks_x = np.arange(0, 110, 10)
minor_ticks_x = np.arange(0, 105, 5)
major_ticks_y = np.arange(0, 17, 2)
minor_ticks_y = np.arange(0, 17, 1)

n = 6
list_color = plt.cm.RdYlGn(np.linspace(0, 1,n))
mpl.rcParams['axes.prop_cycle'] = cycler.cycler('color', list_color)

fig, ax = plt.subplots(2,3, figsize=(50, 25))
ax = ax.ravel()
for i in range(len(region_vulnerability_matrix[:,0])):
    for j in range(len(region_vulnerability_matrix[0])): 
        ax[i].set_title ('Removal in region '+str(int(i+1)), fontsize = 35)
        
        if j < (len(region_vulnerability_matrix[0])-1):
            label = 'Region '+str(int(j+1))
            style = 'o-'
            color = list_color[j]
            w = 5
        else:
            label = 'Total network'
            style = 'o--'
            color = 'black'
            w = 3
        
        ax[i].plot(list_frac, region_vulnerability_matrix[i,j,:], style, label = label,
                   color = color, linewidth = w, markersize = 15)
        
        ax[i].set_xticks(major_ticks_x)
        ax[i].set_xticks(minor_ticks_x, minor=True)
        ax[i].set_yticks(major_ticks_y)
        ax[i].set_yticks(minor_ticks_y, minor=True)
        
        ax[i].tick_params(axis='y', labelcolor='black', labelsize=25)
        ax[i].tick_params(axis='x', labelcolor='black', labelsize=25)
        
        ax[i].grid(which='both')
        ax[i].grid(which='minor', alpha=0.2)
        ax[i].grid(which='major', alpha=0.4)

        ax[i].legend(fontsize = 25, loc = 'upper left', markerscale = 1.)
        
for ax in ax.flat:
    ax.set_xlabel('% removed elements (power network)', fontsize = 25)
    ax.set_ylabel('Failed stations (railway network)', fontsize = 25) 
        
#plt.savefig('immagini/regions/vuln_regions_t50.png', bbox_inches = 'tight')            
plt.show()
   